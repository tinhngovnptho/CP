{
	"CP_template": {
		"scope": "cpp",
		"prefix": "CP_template",
		"body": [
		  "/*",
		  "\tAuthor: tinhnopro",
		  "\tcreated: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
		  "*/",
		  "#include <bits/stdc++.h>",
		  "",
		  "#ifdef LOCAL",
		  "#include \"D:\\\\Tinhnopro\\\\header\\\\debug.h\"",
		  "#else",
		  "#define debug(...) 42",
		  "#endif // LOCAL",
		  "",
		  "#define TASK \"\"",
		  "",
		  "using namespace std;",
		  "",
		  "using i64 = long long;",
		  "",
		  "",
		  "signed main() {",
		  "\tios::sync_with_stdio(false);",
		  "\tcin.tie(0);",
		  "",
		  "\tif (fopen(TASK\".inp\", \"r\")) {",
		  "\t\tfreopen(TASK\".inp\", \"r\", stdin);",
		  "\t\tfreopen(TASK\".out\", \"w\", stdout);",
		  "\t}",
		  "",
		  "}"
		],
		"description": "CP_template"
	},
	"TCP": {
		"scope": "cpp",
		"prefix": "TCP",
		"body": [
		  "#include <bits/stdc++.h>",
		  "",
		  "#define TASK \"\"",
		  "",
		  "using namespace std;",
		  "",
		  "using i64 = long long;",
		  "",
		  "",
		  "signed main() {",
		  "\tios::sync_with_stdio(false);",
		  "\tcin.tie(0);",
		  "",
		  "\tif (fopen(TASK\".inp\", \"r\")) {",
		  "\t\tfreopen(TASK\".inp\", \"r\", stdin);",
		  "\t\tfreopen(TASK\".out\", \"w\", stdout);",
		  "\t}",
		  "",
		  "}"
		],
		"description": "TCP"
	},
	"vector_d": {
    "scope": "cpp",
    "prefix": "vector_d",
    "body": [
      "template <typename T, int D>",
      "struct vec : public vector<vec<T, D - 1>> {",
      "\tstatic_assert(D >= 1, \"Init Error\");",
      "\ttemplate <typename... Args>",
      "\tvec(int n = 0, Args... args) : vector<vec<T, D - 1>>(n, vec<T, D - 1>(args...)) {}",
      "};",
      "",
      "template <typename T>",
      "struct vec<T, 1> : public vector<T> {",
      "\tvec(int n = 0, T val = T()) : vector<T>(n, val) {}",
      "};"
    ],
    "description": "vector_d"
  },
	"stresstest": {
    "scope": "cpp",
    "prefix": "stresstest",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#define TASK \"\"",
      "#define TIME ((1.0 * clock()) / CLOCKS_PER_SEC)",
      "",
      "using namespace std;",
      "",
      "using i64 = long long;",
      "",
      "mt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count());",
      "",
      "i64 randInt(i64 l, i64 r) {",
      "\treturn uniform_int_distribution<i64> (l, r) (rng);",
      "}",
      "",
      "char randaz() {",
      "\treturn char('a' + randInt(0, 25));",
      "}",
      "",
      "char randAZ() {",
      "\treturn char('A' + randInt(0, 25));",
      "}",
      "",
      "void gentest() {",
      "\tofstream cout(TASK\".inp\");",
      "",
      "\tcout.close();",
      "}",
      "",
      "signed main() {",
      "\tfor (int i = 1; i <= 100; ++i) {",
      "\t\tgentest();",
      "",
      "\t\tsystem(TASK\".exe\");",
      "\t\tsystem(TASK\"_bf.exe\");",
      "",
      "\t\tif (system(\"fc \"TASK\".out \"TASK\".ans\") != 0) {",
      "\t\t\treturn 0;",
      "\t\t}",
      "\t}",
      "}",
      ""
    ],
    "description": "stresstest"
  },
	"subtask": {
    "scope": "cpp",
    "prefix": "subtask",
    "body": [
      "namespace Sub {",
      "",
      "\tvoid Main() {",
      "",
      "\t}",
      "",
      "\tbool run() {",
      "",
      "\t\treturn Main(), true;",
      "\t}",
      "}",
      ""
    ],
    "description": "subtask"
  },
	"manacher": {
    "scope": "cpp",
    "prefix": "manacher",
    "body": [
      "const char DUMMY = '.';",
      "",
      "int manacher(string s) {",
      "\tint n = s.size() * 2 - 1;",
      "\tvector <int> f = vector <int>(n, 0);",
      "\tstring a = string(n, DUMMY);",
      "\tfor (int i = 0; i < n; i += 2) a[i] = s[i / 2];",
      "",
      "\tint l = 0, r = -1, center, res = 0;",
      "\tfor (int i = 0, j = 0; i < n; i++) {",
      "\t\tj = (i > r ? 0 : min(f[l + r - i], r - i)) + 1;",
      "\t\twhile (i - j >= 0 && i + j < n && a[i - j] == a[i + j]) j++;",
      "\t\tf[i] = --j;",
      "\t\tif (i + j > r) {",
      "\t\t\tr = i + j;",
      "\t\t\tl = i - j;",
      "\t\t}",
      "",
      "\t\tint len = (f[i] + i % 2) / 2 * 2 + 1 - i % 2;",
      "\t\tif (len > res) {",
      "\t\t\tres = len;",
      "\t\t\tcenter = i;",
      "\t\t}",
      "\t}",
      "",
      "\treturn res;",
      "}",
      ""
    ],
    "description": "manacher"
  },
	"bigint": {
    "scope": "cpp",
    "prefix": "bigint",
    "body": [
      "const int base = 1000000000;",
      "const int base_digits = 9;",
      "",
      "",
      "struct bigint {",
      "\tvector<int> a;",
      "\tint sign;",
      "",
      "\tbigint() :",
      "\t\t\tsign(1) {",
      "\t}",
      "",
      "\tbigint(long long v) {",
      "\t\t\t*this = v;",
      "\t}",
      "",
      "\tbigint(const string &s) {",
      "\t\t\tread(s);",
      "\t}",
      "",
      "\tvoid operator=(const bigint &v) {",
      "\t\t\tsign = v.sign;",
      "\t\t\ta = v.a;",
      "\t}",
      "",
      "\tvoid operator=(long long v) {",
      "\t\t\tsign = 1;",
      "\t\t\tif (v < 0)",
      "\t\t\t\t\tsign = -1, v = -v;",
      "\t\t\tfor (; v > 0; v = v / base)",
      "\t\t\t\t\ta.push_back(v % base);",
      "\t}",
      "",
      "\tbigint operator+(const bigint &v) const {",
      "\t\t\tif (sign == v.sign) {",
      "\t\t\t\t\tbigint res = v;",
      "",
      "\t\t\t\t\tfor (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) | carry; ++i) {",
      "\t\t\t\t\t\t\tif (i == (int) res.a.size())",
      "\t\t\t\t\t\t\t\t\tres.a.push_back(0);",
      "\t\t\t\t\t\t\tres.a[i] += carry + (i < (int) a.size() ? a[i] : 0);",
      "\t\t\t\t\t\t\tcarry = res.a[i] >= base;",
      "\t\t\t\t\t\t\tif (carry)",
      "\t\t\t\t\t\t\t\t\tres.a[i] -= base;",
      "\t\t\t\t\t}",
      "\t\t\t\t\treturn res;",
      "\t\t\t}",
      "\t\t\treturn *this - (-v);",
      "\t}",
      "",
      "\tbigint operator-(const bigint &v) const {",
      "\t\t\tif (sign == v.sign) {",
      "\t\t\t\t\tif (abs() >= v.abs()) {",
      "\t\t\t\t\t\t\tbigint res = *this;",
      "\t\t\t\t\t\t\tfor (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
      "\t\t\t\t\t\t\t\t\tres.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
      "\t\t\t\t\t\t\t\t\tcarry = res.a[i] < 0;",
      "\t\t\t\t\t\t\t\t\tif (carry)",
      "\t\t\t\t\t\t\t\t\t\t\tres.a[i] += base;",
      "\t\t\t\t\t\t\t}",
      "\t\t\t\t\t\t\tres.trim();",
      "\t\t\t\t\t\t\treturn res;",
      "\t\t\t\t\t}",
      "\t\t\t\t\treturn -(v - *this);",
      "\t\t\t}",
      "\t\t\treturn *this + (-v);",
      "\t}",
      "",
      "\tvoid operator*=(int v) {",
      "\t\t\tif (v < 0)",
      "\t\t\t\t\tsign = -sign, v = -v;",
      "\t\t\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
      "\t\t\t\t\tif (i == (int) a.size())",
      "\t\t\t\t\t\t\ta.push_back(0);",
      "\t\t\t\t\tlong long cur = a[i] * (long long) v + carry;",
      "\t\t\t\t\tcarry = (int) (cur / base);",
      "\t\t\t\t\ta[i] = (int) (cur % base);",
      "\t\t\t\t\t//asm(\"divl %ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
      "\t\t\t}",
      "\t\t\ttrim();",
      "\t}",
      "",
      "\tbigint operator*(int v) const {",
      "\t\t\tbigint res = *this;",
      "\t\t\tres *= v;",
      "\t\t\treturn res;",
      "\t}",
      "",
      "\tfriend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
      "\t\t\tint norm = base / (b1.a.back() + 1);",
      "\t\t\tbigint a = a1.abs() * norm;",
      "\t\t\tbigint b = b1.abs() * norm;",
      "\t\t\tbigint q, r;",
      "\t\t\tq.a.resize(a.a.size());",
      "",
      "\t\t\tfor (int i = a.a.size() - 1; i >= 0; i--) {",
      "\t\t\t\t\tr *= base;",
      "\t\t\t\t\tr += a.a[i];",
      "\t\t\t\t\tint s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
      "\t\t\t\t\tint s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
      "\t\t\t\t\tint d = ((long long) base * s1 + s2) / b.a.back();",
      "\t\t\t\t\tr -= b * d;",
      "\t\t\t\t\twhile (r < 0)",
      "\t\t\t\t\t\t\tr += b, --d;",
      "\t\t\t\t\tq.a[i] = d;",
      "\t\t\t}",
      "",
      "\t\t\tq.sign = a1.sign * b1.sign;",
      "\t\t\tr.sign = a1.sign;",
      "\t\t\tq.trim();",
      "\t\t\tr.trim();",
      "\t\t\treturn make_pair(q, r / norm);",
      "\t}",
      "",
      "\tbigint operator/(const bigint &v) const {",
      "\t\t\treturn divmod(*this, v).first;",
      "\t}",
      "",
      "\tbigint operator%(const bigint &v) const {",
      "\t\t\treturn divmod(*this, v).second;",
      "\t}",
      "",
      "\tvoid operator/=(int v) {",
      "\t\t\tif (v < 0)",
      "\t\t\t\t\tsign = -sign, v = -v;",
      "\t\t\tfor (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
      "\t\t\t\t\tlong long cur = a[i] + rem * (long long) base;",
      "\t\t\t\t\ta[i] = (int) (cur / v);",
      "\t\t\t\t\trem = (int) (cur % v);",
      "\t\t\t}",
      "\t\t\ttrim();",
      "\t}",
      "",
      "\tbigint operator/(int v) const {",
      "\t\t\tbigint res = *this;",
      "\t\t\tres /= v;",
      "\t\t\treturn res;",
      "\t}",
      "",
      "\tint operator%(int v) const {",
      "\t\t\tif (v < 0)",
      "\t\t\t\t\tv = -v;",
      "\t\t\tint m = 0;",
      "\t\t\tfor (int i = a.size() - 1; i >= 0; --i)",
      "\t\t\t\t\tm = (a[i] + m * (long long) base) % v;",
      "\t\t\treturn m * sign;",
      "\t}",
      "",
      "\tvoid operator+=(const bigint &v) {",
      "\t\t\t*this = *this + v;",
      "\t}",
      "\tvoid operator-=(const bigint &v) {",
      "\t\t\t*this = *this - v;",
      "\t}",
      "\tvoid operator*=(const bigint &v) {",
      "\t\t\t*this = *this * v;",
      "\t}",
      "\tvoid operator/=(const bigint &v) {",
      "\t\t\t*this = *this / v;",
      "\t}",
      "",
      "\tbool operator<(const bigint &v) const {",
      "\t\t\tif (sign != v.sign)",
      "\t\t\t\t\treturn sign < v.sign;",
      "\t\t\tif (a.size() != v.a.size())",
      "\t\t\t\t\treturn a.size() * sign < v.a.size() * v.sign;",
      "\t\t\tfor (int i = a.size() - 1; i >= 0; i--)",
      "\t\t\t\t\tif (a[i] != v.a[i])",
      "\t\t\t\t\t\t\treturn a[i] * sign < v.a[i] * sign;",
      "\t\t\treturn false;",
      "\t}",
      "",
      "\tbool operator>(const bigint &v) const {",
      "\t\t\treturn v < *this;",
      "\t}",
      "\tbool operator<=(const bigint &v) const {",
      "\t\t\treturn !(v < *this);",
      "\t}",
      "\tbool operator>=(const bigint &v) const {",
      "\t\t\treturn !(*this < v);",
      "\t}",
      "\tbool operator==(const bigint &v) const {",
      "\t\t\treturn !(*this < v) && !(v < *this);",
      "\t}",
      "\tbool operator!=(const bigint &v) const {",
      "\t\t\treturn *this < v || v < *this;",
      "\t}",
      "",
      "\tvoid trim() {",
      "\t\t\twhile (!a.empty() && !a.back())",
      "\t\t\t\t\ta.pop_back();",
      "\t\t\tif (a.empty())",
      "\t\t\t\t\tsign = 1;",
      "\t}",
      "",
      "\tbool isZero() const {",
      "\t\t\treturn a.empty() || (a.size() == 1 && !a[0]);",
      "\t}",
      "",
      "\tbigint operator-() const {",
      "\t\t\tbigint res = *this;",
      "\t\t\tres.sign = -sign;",
      "\t\t\treturn res;",
      "\t}",
      "",
      "\tbigint abs() const {",
      "\t\t\tbigint res = *this;",
      "\t\t\tres.sign *= res.sign;",
      "\t\t\treturn res;",
      "\t}",
      "",
      "\tlong long longValue() const {",
      "\t\t\tlong long res = 0;",
      "\t\t\tfor (int i = a.size() - 1; i >= 0; i--)",
      "\t\t\t\t\tres = res * base + a[i];",
      "\t\t\treturn res * sign;",
      "\t}",
      "",
      "\tfriend bigint gcd(const bigint &a, const bigint &b) {",
      "\t\t\treturn b.isZero() ? a : gcd(b, a % b);",
      "\t}",
      "\tfriend bigint lcm(const bigint &a, const bigint &b) {",
      "\t\t\treturn a / gcd(a, b) * b;",
      "\t}",
      "",
      "\tvoid read(const string &s) {",
      "\t\t\tsign = 1;",
      "\t\t\ta.clear();",
      "\t\t\tint pos = 0;",
      "\t\t\twhile (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
      "\t\t\t\t\tif (s[pos] == '-')",
      "\t\t\t\t\t\t\tsign = -sign;",
      "\t\t\t\t\t++pos;",
      "\t\t\t}",
      "\t\t\tfor (int i = s.size() - 1; i >= pos; i -= base_digits) {",
      "\t\t\t\t\tint x = 0;",
      "\t\t\t\t\tfor (int j = max(pos, i - base_digits + 1); j <= i; j++)",
      "\t\t\t\t\t\t\tx = x * 10 + s[j] - '0';",
      "\t\t\t\t\ta.push_back(x);",
      "\t\t\t}",
      "\t\t\ttrim();",
      "\t}",
      "",
      "\tfriend istream& operator>>(istream &stream, bigint &v) {",
      "\t\t\tstring s;",
      "\t\t\tstream >> s;",
      "\t\t\tv.read(s);",
      "\t\t\treturn stream;",
      "\t}",
      "",
      "\tfriend ostream& operator<<(ostream &stream, const bigint &v) {",
      "\t\t\tif (v.sign == -1)",
      "\t\t\t\t\tstream << '-';",
      "\t\t\tstream << (v.a.empty() ? 0 : v.a.back());",
      "\t\t\tfor (int i = (int) v.a.size() - 2; i >= 0; --i)",
      "\t\t\t\t\tstream << setw(base_digits) << setfill('0') << v.a[i];",
      "\t\t\treturn stream;",
      "\t}",
      "",
      "\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
      "\t\t\tvector<long long> p(max(old_digits, new_digits) + 1);",
      "\t\t\tp[0] = 1;",
      "\t\t\tfor (int i = 1; i < (int) p.size(); i++)",
      "\t\t\t\t\tp[i] = p[i - 1] * 10;",
      "\t\t\tvector<int> res;",
      "\t\t\tlong long cur = 0;",
      "\t\t\tint cur_digits = 0;",
      "\t\t\tfor (int i = 0; i < (int) a.size(); i++) {",
      "\t\t\t\t\tcur += a[i] * p[cur_digits];",
      "\t\t\t\t\tcur_digits += old_digits;",
      "\t\t\t\t\twhile (cur_digits >= new_digits) {",
      "\t\t\t\t\t\t\tres.push_back(int(cur % p[new_digits]));",
      "\t\t\t\t\t\t\tcur /= p[new_digits];",
      "\t\t\t\t\t\t\tcur_digits -= new_digits;",
      "\t\t\t\t\t}",
      "\t\t\t}",
      "\t\t\tres.push_back((int) cur);",
      "\t\t\twhile (!res.empty() && !res.back())",
      "\t\t\t\t\tres.pop_back();",
      "\t\t\treturn res;",
      "\t}",
      "",
      "\ttypedef vector<long long> vll;",
      "",
      "\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {",
      "\t\t\tint n = a.size();",
      "\t\t\tvll res(n + n);",
      "\t\t\tif (n <= 32) {",
      "\t\t\t\t\tfor (int i = 0; i < n; i++)",
      "\t\t\t\t\t\t\tfor (int j = 0; j < n; j++)",
      "\t\t\t\t\t\t\t\t\tres[i + j] += a[i] * b[j];",
      "\t\t\t\t\treturn res;",
      "\t\t\t}",
      "",
      "\t\t\tint k = n >> 1;",
      "\t\t\tvll a1(a.begin(), a.begin() + k);",
      "\t\t\tvll a2(a.begin() + k, a.end());",
      "\t\t\tvll b1(b.begin(), b.begin() + k);",
      "\t\t\tvll b2(b.begin() + k, b.end());",
      "",
      "\t\t\tvll a1b1 = karatsubaMultiply(a1, b1);",
      "\t\t\tvll a2b2 = karatsubaMultiply(a2, b2);",
      "",
      "\t\t\tfor (int i = 0; i < k; i++)",
      "\t\t\t\t\ta2[i] += a1[i];",
      "\t\t\tfor (int i = 0; i < k; i++)",
      "\t\t\t\t\tb2[i] += b1[i];",
      "",
      "\t\t\tvll r = karatsubaMultiply(a2, b2);",
      "\t\t\tfor (int i = 0; i < (int) a1b1.size(); i++)",
      "\t\t\t\t\tr[i] -= a1b1[i];",
      "\t\t\tfor (int i = 0; i < (int) a2b2.size(); i++)",
      "\t\t\t\t\tr[i] -= a2b2[i];",
      "",
      "\t\t\tfor (int i = 0; i < (int) r.size(); i++)",
      "\t\t\t\t\tres[i + k] += r[i];",
      "\t\t\tfor (int i = 0; i < (int) a1b1.size(); i++)",
      "\t\t\t\t\tres[i] += a1b1[i];",
      "\t\t\tfor (int i = 0; i < (int) a2b2.size(); i++)",
      "\t\t\t\t\tres[i + n] += a2b2[i];",
      "\t\t\treturn res;",
      "\t}",
      "",
      "\tbigint operator*(const bigint &v) const {",
      "\t\t\tvector<int> a6 = convert_base(this->a, base_digits, 6);",
      "\t\t\tvector<int> b6 = convert_base(v.a, base_digits, 6);",
      "\t\t\tvll a(a6.begin(), a6.end());",
      "\t\t\tvll b(b6.begin(), b6.end());",
      "\t\t\twhile (a.size() < b.size())",
      "\t\t\t\t\ta.push_back(0);",
      "\t\t\twhile (b.size() < a.size())",
      "\t\t\t\t\tb.push_back(0);",
      "\t\t\twhile (a.size() & (a.size() - 1))",
      "\t\t\t\t\ta.push_back(0), b.push_back(0);",
      "\t\t\tvll c = karatsubaMultiply(a, b);",
      "\t\t\tbigint res;",
      "\t\t\tres.sign = sign * v.sign;",
      "\t\t\tfor (int i = 0, carry = 0; i < (int) c.size(); i++) {",
      "\t\t\t\t\tlong long cur = c[i] + carry;",
      "\t\t\t\t\tres.a.push_back((int) (cur % 1000000));",
      "\t\t\t\t\tcarry = (int) (cur / 1000000);",
      "\t\t\t}",
      "\t\t\tres.a = convert_base(res.a, 6, base_digits);",
      "\t\t\tres.trim();",
      "\t\t\treturn res;",
      "\t}",
      "};",
      ""
    ],
    "description": "bigint"
  },
	"line_container": {
    "scope": "cpp",
    "prefix": "line_container",
    "body": [
      "struct Line {",
      "\t\tmutable long long k, m, p;",
      "\t\tLine(long long k, long long m, long long p): k(k), m(m), p(p) {}",
      "\t\tbool operator < (const Line& o) const { return k < o.k; }",
      "\t\tbool operator < (long long x) const { return p < x; }",
      "};",
      "struct LineContainer: multiset <Line, less<>> {",
      "\t\t// (for doubles, use inf = 1/.0, div(a,b) = a/b)",
      "\t\tstatic const long long inf = 4e18;",
      "\t\tlong long div(long long a, long long b) { // floored division",
      "\t\t\t\treturn a / b - ((a ^ b) < 0 && a % b);",
      "\t\t}",
      "\t\tbool isect(iterator x, iterator y) {",
      "\t\t\t\tif (y == end()) return x->p = inf, 0;",
      "\t\t\t\tif (x->k == y->k) x->p = x->m > y->m ? inf : -inf;",
      "\t\t\t\telse x->p = div(y->m - x->m, x->k - y->k);",
      "\t\t\t\treturn x->p >= y->p;",
      "\t\t}",
      "\t\tvoid add(long long k, long long m) {",
      "\t\t\t\tauto z = emplace(k, m, 0), y = z++, x = y;",
      "\t\t\t\twhile (isect(y, z)) z = erase(z);",
      "\t\t\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
      "\t\t\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
      "\t\t\t\t\t\tisect(x, erase(y));",
      "\t\t}",
      "\t\tlong long query(long long x) {",
      "\t\t\t\tassert(!empty());",
      "\t\t\t\tauto l = *lower_bound(x);",
      "\t\t\t\treturn l.k * x + l.m;",
      "\t\t}",
      "};"
    ],
    "description": "line_container"
  },
	"CHT": {
    "scope": "cpp",
    "prefix": "CHT",
    "body": [
      "struct Line {",
      "\t\tlong long a, b;",
      "\t\tLine(long long a = 0, long long b = INF): a(a), b(b) {}",
      "\t\tlong long eval(long long x) { return a * x + b; }",
      "};",
      "struct ConvexHullTrick {",
      "\t\tvector <Line> lines; int ptr;",
      "\t\tConvexHullTrick(): ptr(0) {}",
      "\t\tbool bad(Line a, Line b, Line c) { return (long double) (c.b - a.b) / (a.a - c.a) < (long double) (b.b - a.b) / (a.a - b.a); }",
      "\t\tvoid addLine(long long a, long long b) {",
      "\t\t\t\tLine l(a, b);",
      "\t\t\t\twhile (lines.size() >= 2 && bad(lines.end()[-2], lines.back(), l)) lines.pop_back();",
      "\t\t\t\tlines.push_back(l);",
      "\t\t}",
      "\t\tLine getMin(long long x) {",
      "\t\t\t\tif (ptr >= (int) lines.size()) ptr = (int) lines.size() - 1;",
      "\t\t\t\twhile (ptr < (int) lines.size() - 1 && lines[ptr].eval(x) > lines[ptr + 1].eval(x)) ++ptr;",
      "\t\t\t\treturn lines[ptr];",
      "\t\t}",
      "};",
      "using CHT = ConvexHullTrick;"
    ],
    "description": "CHT"
  },
	"matrix": {
    "scope": "cpp",
    "prefix": "matrix",
    "body": [
      "template <typename T>",
      "struct Matrix {",
      "\t\tvector<vector<T>> mat;",
      "\t\tint r, c;",
      "",
      "\t\tMatrix(int r = 0, int c = 0): r(r), c(c), mat(r, vector<T>(c, 0)) {}",
      "\t\tMatrix(vector<vector<T>> mat): r(mat.size()), c(mat[0].size()), mat(mat) {}",
      "",
      "\t\tMatrix operator *(const Matrix &ot) const {",
      "\t\t\t\tMatrix res(r, ot.c);",
      "\t\t\t\tfor (int i = 0; i < r; ++i)",
      "\t\t\t\t\tfor (int j = 0; j < c; ++j) {",
      "\t\t\t\t\t\tfor (int k = 0; k < c; ++k) add(res.mat[i][j], mat[i][k] * ot.mat[k][j]);",
      "\t\t\t\t}",
      "\t\t\t\treturn res;",
      "\t\t}",
      "\t\tMatrix pow(i64 b) const {",
      "\t\t\t\tMatrix res(r, c), a = *this;",
      "\t\t\t\tfor (int i = 0; i < r; ++i) res.mat[i][i] = 1;",
      "\t\t\t\tfor (; b; b >>= 1LL, a = a * a) if (b & 1LL) res = res * a;",
      "\t\t\t\treturn res;",
      "\t\t}",
      "};"
    ],
    "description": "matrix"
  },
	"tries": {
    "scope": "cpp",
    "prefix": "tries",
    "body": [
      "struct Trie {",
      "\t\tstruct Node {",
      "\t\t\t\tNode *child[26];",
      "\t\t\t\tbool isEnd;",
      "\t\t\t\tNode() {",
      "\t\t\t\t\t\tFOR(i, 0, 26) child[i] = nullptr;",
      "\t\t\t\t\t\tisEnd = false;",
      "\t\t\t\t}",
      "\t\t};",
      " ",
      "\t\tNode *root;",
      " ",
      "\t\tTrie() {",
      "\t\t\t\troot = new Node();",
      "\t\t}",
      " ",
      "\t\tvoid add_string(string s) {",
      "\t\t\t\tNode *p = root;",
      "\t\t\t\tFOR(i, 0, s.size()) {",
      "\t\t\t\t\t\tint id = s[i] - 'a';",
      "\t\t\t\t\t\tif (p->child[id] == nullptr) p->child[id] = new Node();",
      "\t\t\t\t\t\tp = p->child[id];",
      "\t\t\t\t}",
      "\t\t\t\tp->isEnd = true;",
      "\t\t}",
      " ",
      "\t\tbool isExist(string s) {",
      "\t\t\t\tNode *p = root;",
      "\t\t\t\tFOR(i, 0, s.size()) {",
      "\t\t\t\t\t\tint id\t= s[i] - 'a';",
      "\t\t\t\t\t\tif (p->child[id] == nullptr) return false;",
      "\t\t\t\t\t\tp = p->child[id];",
      "\t\t\t\t}",
      "\t\t\t\treturn p->isEnd;",
      "\t\t}",
      "} trie;"
    ],
    "description": "tries"
  },
}