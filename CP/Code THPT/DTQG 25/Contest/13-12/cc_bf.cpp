// author : anhtun_hi , nqg
// 25-26.12.2024

#include <bits/stdc++.h>
#define fi first
#define se second
#define all(x) x.begin(), x.end()
#define reset(h, v)    memset(h, v, sizeof h)
#define Forv(i, a)     for(auto& i : a)
#define For(i, a, b)   for(int i = a; i <= b; ++i)
#define Ford(i, a, b)  for(int i = a; i >= b; --i)
#define c_bit(i)     __builtin_popcountll(i)
#define Bit(mask, i)    ((mask >> i) & 1LL)
#define onbit(mask, i)  ((mask) bitor (1LL << i))
#define offbit(mask, i) ((mask) &~ (1LL << i))
#define Log2(x) (63 - __builtin_clzll(x))
#define TIME (1.0 * clock() / CLOCKS_PER_SEC)
using namespace std;

using ll = long long;
using ii = pair<ll, ll>;
using db = long double;
using ull = unsigned long long;

namespace std {
    template <typename T, int D>
    struct _vector : public vector <_vector <T, D - 1>> {
        static_assert(D >= 1, "Dimension must be positive!");
        template <typename... Args>
        _vector(int n = 0, Args... args) : vector <_vector <T, D - 1>> (n, _vector <T, D - 1> (args...)) {}
    };
    template <typename T> struct _vector <T, 1> : public vector <T> {
        _vector(int n = 0, const T& val = T()) : vector <T> (n, val) {}
    };
    template <class A, class B> bool minimize(A &a, B b){return a > b ? a = b, true : false;}
    template <class A, class B> bool maximize(A &a, B b){return a < b ? a = b, true : false;}
}
const int dx[] = {0, 0, +1, -1}, dy[] = {-1, +1, 0, 0}, LOG = 20, base = 311, inf = 1e9 + 5;
const int MAXN = 1e6 + 5;
const  ll  mod = 1e9 + 7;
const  ll   oo = 1e18;

//#define int long long


bool check[100][100];
int n, d[MAXN];

// vector<string> palin;

string cc[] = {"01011010","01022010","01033010","01044010","01055010","01066010","01077010","01088010","01099010","01100110","01111110","01122110","02011020","02022020","02033020","02044020","02055020","02066020","02077020","02088020","02099020","02100120","02111120","02122120","03011030","03022030","03033030","03044030","03055030","03066030","03077030","03088030","03099030","03100130","03111130","03122130","04011040","04022040","04033040","04044040","04055040","04066040","04077040","04088040","04099040","04100140","04111140","04122140","05011050","05022050","05033050","05044050","05055050","05066050","05077050","05088050","05099050","05100150","05111150","05122150","06011060","06022060","06033060","06044060","06055060","06066060","06077060","06088060","06099060","06100160","06111160","06122160","07011070","07022070","07033070","07044070","07055070","07066070","07077070","07088070","07099070","07100170","07111170","07122170","08011080","08022080","08033080","08044080","08055080","08066080","08077080","08088080","08099080","08100180","08111180","08122180","09011090","09022090","09033090","09044090","09055090","09066090","09077090","09088090","09099090","09100190","09111190","09122190","10011001","10022001","10033001","10044001","10055001","10066001","10077001","10088001","10099001","10100101","10111101","10122101","11011011","11022011","11033011","11044011","11055011","11066011","11077011","11088011","11099011","11100111","11111111","11122111","12011021","12022021","12033021","12044021","12055021","12066021","12077021","12088021","12099021","12100121","12111121","12122121","13011031","13022031","13033031","13044031","13055031","13066031","13077031","13088031","13099031","13100131","13111131","13122131","14011041","14022041","14033041","14044041","14055041","14066041","14077041","14088041","14099041","14100141","14111141","14122141","15011051","15022051","15033051","15044051","15055051","15066051","15077051","15088051","15099051","15100151","15111151","15122151","16011061","16022061","16033061","16044061","16055061","16066061","16077061","16088061","16099061","16100161","16111161","16122161","17011071","17022071","17033071","17044071","17055071","17066071","17077071","17088071","17099071","17100171","17111171","17122171","18011081","18022081","18033081","18044081","18055081","18066081","18077081","18088081","18099081","18100181","18111181","18122181","19011091","19022091","19033091","19044091","19055091","19066091","19077091","19088091","19099091","19100191","19111191","19122191","20011002","20022002","20033002","20044002","20055002","20066002","20077002","20088002","20099002","20100102","20111102","20122102","21011012","21022012","21033012","21044012","21055012","21066012","21077012","21088012","21099012","21100112","21111112","21122112","22011022","22022022","22033022","22044022","22055022","22066022","22077022","22088022","22099022","22100122","22111122","22122122","23011032","23022032","23033032","23044032","23055032","23066032","23077032","23088032","23099032","23100132","23111132","23122132","24011042","24022042","24033042","24044042","24055042","24066042","24077042","24088042","24099042","24100142","24111142","24122142","25011052","25022052","25033052","25044052","25055052","25066052","25077052","25088052","25099052","25100152","25111152","25122152","26011062","26022062","26033062","26044062","26055062","26066062","26077062","26088062","26099062","26100162","26111162","26122162","27011072","27022072","27033072","27044072","27055072","27066072","27077072","27088072","27099072","27100172","27111172","27122172","28011082","28022082","28033082","28044082","28055082","28066082","28077082","28088082","28099082","28100182","28111182","28122182","29011092","29022092","29033092","29044092","29055092","29066092","29077092","29088092","29099092","29100192","29111192","29122192","30011003","30033003","30044003","30055003","30066003","30077003","30088003","30099003","30100103","30111103","30122103","31011013","31033013","31055013","31077013","31088013","31100113","31122113"};

int ngay(const string &x) {
    int sum = 0;
    For(i, 0, 1) sum = sum * 10 + x[i] - '0';
    return sum;
}
int thang(const string &x) {
    int sum = 0;
    For(i, 2, 3) sum = sum * 10 + x[i] - '0';
    return sum;
}
int nam(const string &x) {
    int sum = 0;
    For(i, 4, 7) sum = sum * 10 + x[i] - '0';
    return sum;
}

struct cmp{
    bool operator()(const string &x, const string &y) const{
        return (nam(x) < nam(y) || (nam(x) == nam(y) && thang(x) < thang(y)) || (nam(x) == nam(y) && thang(x) == thang(y) && ngay(x) < ngay(y)));
    }
};

void Solve() {
    cin >> n;
    set<string, cmp> palin;
    For(i, 0, 365) palin.insert(cc[i]);
    For(i, 1, n){
        string s; cin >> s;
        string x = "";
        Forv(v, s) if (v !='.') x += v;
        string ans = "";
        x = *palin.upper_bound(x);

        For(i, 0, 1) ans += x[i];
        ans += '.';
        For(i, 2, 3) ans += x[i];
        ans += '.';
        For(i, 4, 7) ans += x[i];
        ans += '.';
        cout << ans << '\n';
    }
}

signed main() {
    cin.tie(0) -> sync_with_stdio(0);
    if(fopen("cc.inp", "r")) {
        freopen("cc.inp", "r", stdin);
        freopen("cc.ans", "w", stdout);
    }

    int t = 1;
//    cin >> t;
    while(t --) Solve();
    return 0;
}
